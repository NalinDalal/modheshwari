// -------------------- OVERVIEW --------------------
// Models a community structure of families, gotras, and administrative hierarchy.
// Supports users, family lineage, event workflows, approvals, notifications,
// and resource tracking.
//
// -------------------- FAMILY LOGIC --------------------
// - Each User belongs to exactly ONE active Family via FamilyMember.
// - When a member marries or moves, only FamilyMember.familyId changes.
// - Historical family links are retained (no hard deletions).
//
// -------------------- EVENT WORKFLOW --------------------
// 1. A User (usually FAMILY_HEAD) creates an Event → status = PENDING.
// 2. System auto-generates EventApproval records for:
//      - COMMUNITY_HEAD
//      - COMMUNITY_SUBHEAD
//      - GOTRA_HEAD
// 3. Approvers may Approve / Reject / Request Changes.
// 4. Once all required roles approve → Event.status = APPROVED.
// 5. Creator and heads receive Notifications at each step.
//
// -------------------- ROLE HIERARCHY --------------------
// COMMUNITY_HEAD     → Full control, top-level approvals
// COMMUNITY_SUBHEAD  → Co-reviewer / secondary approval
// GOTRA_HEAD         → Gotra-level oversight
// FAMILY_HEAD        → Leads a single family
// MEMBER             → Regular member
//

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// -------------------- USER --------------------
// Represents a community member. May head a family or perform admin actions.
//

model User {
  id        String         @id @default(uuid())
  email     String
  password  String
  name      String
  role      Role
  profile   Profile?
  families  FamilyMember[]
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  status    Boolean

  // Relations
  headedFamilies            Family[]            @relation("FamilyHead")
  createdEvents             Event[]             @relation("EventCreatedBy")
  eventRegistrations        EventRegistration[]
  payments                  Payment[]
  requestedResourceRequests ResourceRequest[]   @relation("RequestedBy")
  approvedResourceRequests  ResourceRequest[]   @relation("ApprovedBy")
  notifications             Notification[]

  // New reverse relation for EventApproval
  eventApprovalsReviewed EventApproval[] @relation("UserEventApprovals")

  // Reverse relation for resource request approval steps
  resourceRequestApprovals ResourceRequestApproval[] @relation("UserResourceRequestApprovals")

  // Member invites relations
  memberInvitesReceived MemberInvite[] @relation("InvitedUser")
  memberInvitesReviewed MemberInvite[] @relation("InviteReviewedBy")

  // User relations
  relationsFrom UserRelation[] @relation("FromUser")
  relationsTo   UserRelation[] @relation("ToUser")

  // Reverse relations for StatusUpdateRequest
  statusUpdateRequestsMade   StatusUpdateRequest[] @relation("StatusUpdateRequestedBy")
  statusUpdateRequestsTarget StatusUpdateRequest[] @relation("TargetUser")

  // Reverse relation for StatusUpdateApproval
  statusUpdateApprovals StatusUpdateApproval[] @relation("UserStatusUpdateApprovals")
}

//
// -------------------- ROLE ENUM --------------------
// Defines user hierarchy and permissions.
//

enum Role {
  COMMUNITY_HEAD
  COMMUNITY_SUBHEAD
  GOTRA_HEAD
  FAMILY_HEAD
  MEMBER
}

//
// -------------------- PROFILE --------------------
// Stores personal non-relational data.
//

model Profile {
  id         String  @id @default(uuid())
  user       User    @relation(fields: [userId], references: [id])
  userId     String  @unique
  phone      String?
  address    String?
  profession String?
  gotra      String?
  location   String?
  status     String? // e.g. "alive", "deceased"
   bloodGroup String? // Add this line
}

//
// -------------------- FAMILY --------------------
// Represents a nuclear family unit led by one head.
//

model Family {
  id           String         @id @default(uuid())
  name         String
  uniqueId     String         @unique
  members      FamilyMember[]
  headId       String?
  head         User?          @relation("FamilyHead", fields: [headId], references: [id])
  createdAt    DateTime       @default(now())
  MemberInvite MemberInvite[]
}

//
// -------------------- FAMILY MEMBER --------------------
// Junction model linking User <-> Family.
// Moving a user to another family updates familyId.
//

model FamilyMember {
  id       String   @id @default(uuid())
  family   Family   @relation(fields: [familyId], references: [id])
  familyId String
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  role     Role
  joinedAt DateTime @default(now())
  // This allows:
  //  ✅ Same user can exist in multiple families.
  //  ✅ Same user can hold different roles in same or different families.
  //  ❌ Same user cannot hold the same role twice in the same family.

  @@unique([familyId, userId, role]) // ensures one unique role per user within a family
}

//
// -------------------- USER RELATION --------------------
// Tracks relationship between two users (e.g., spouse, parent, sibling, etc.)
// This allows modeling complex family trees.
//

model UserRelation {
  id         String       @id @default(uuid())
  fromUser   User         @relation("FromUser", fields: [fromUserId], references: [id])
  fromUserId String
  toUser     User         @relation("ToUser", fields: [toUserId], references: [id])
  toUserId   String
  type       RelationType
  createdAt  DateTime     @default(now())

  @@unique([fromUserId, toUserId, type])
}

//
// -------------------- RELATION TYPE ENUM --------------------
// Defines recognized user relationship kinds.
//

enum RelationType {
  SPOUSE
  PARENT
  CHILD
  SIBLING
}

//
// -------------------- EVENT --------------------
// Represents a community event created by a user.
// Goes through multi-role approval pipeline.
//

model Event {
  id            String              @id @default(uuid())
  name          String
  description   String?
  date          DateTime
  venue         String?
  createdBy     User                @relation("EventCreatedBy", fields: [createdById], references: [id])
  createdById   String
  status        EventStatus         @default(PENDING)
  approvals     EventApproval[] // handled cascade from EventApproval side
  registrations EventRegistration[]
  payments      Payment[]
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  Notification  Notification[]
}

//
// -------------------- EVENT STATUS ENUM --------------------
// Tracks the lifecycle of an event.
//

enum EventStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

//
// -------------------- EVENT APPROVAL --------------------
// Tracks the review/approval workflow for events.
//

model EventApproval {
  id           String         @id @default(uuid())
  event        Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId      String
  approver     User           @relation("UserEventApprovals", fields: [approverId], references: [id])
  approverId   String
  approverName String
  role         Role
  status       ApprovalStatus
  remarks      String?
  reviewedAt   DateTime?
  createdAt    DateTime       @default(now())

  @@unique([eventId, approverId])
}

//
// -------------------- EVENT REGISTRATION --------------------
// Tracks event participation.
//

model EventRegistration {
  id           String   @id @default(uuid())
  event        Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId      String
  user         User     @relation(fields: [userId], references: [id])
  userId       String
  registeredAt DateTime @default(now())
}

//
// -------------------- PAYMENT --------------------
// Tracks event-related payments.
//

model Payment {
  id           String         @id @default(uuid())
  event        Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId      String
  user         User           @relation(fields: [userId], references: [id])
  userId       String
  amount       Float
  status       String
  createdAt    DateTime       @default(now())
  Notification Notification[]
}

//
// -------------------- RESOURCE REQUEST --------------------
// Tracks user requests and admin approvals for community resources.
//

model ResourceRequest {
  id           String                    @id @default(uuid())
  user         User                      @relation("RequestedBy", fields: [userId], references: [id])
  userId       String
  resource     String
  status       ApprovalStatus // request's overall status
  // keep optional last-approver snapshot for quick access
  approver     User?                     @relation("ApprovedBy", fields: [approverId], references: [id])
  approverId   String?
  approverName String? // cached name of approver for quick access
  // Detailed approval steps (hierarchical)
  approvals    ResourceRequestApproval[]
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  Notification Notification[]
}

model ResourceRequestApproval {
  id           String          @id @default(uuid())
  request      ResourceRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  requestId    String
  approver     User            @relation("UserResourceRequestApprovals", fields: [approverId], references: [id])
  approverId   String
  approverName String
  role         Role
  status       ApprovalStatus
  remarks      String?
  reviewedAt   DateTime?
  createdAt    DateTime        @default(now())

  @@unique([requestId, approverId])
}

//
// -------------------- NOTIFICATION --------------------
// System-generated user alerts.
//

model Notification {
  id        String              @id @default(uuid())
  user      User                @relation(fields: [userId], references: [id])
  userId    String
  type      NotificationType // e.g. EVENT_APPROVAL, RESOURCE_REQUEST
  channel   NotificationChannel @default(IN_APP)
  message   String
  read      Boolean             @default(false)
  createdAt DateTime            @default(now())

  // Optional links to related entities
  event             Event?           @relation(fields: [eventId], references: [id])
  eventId           String?
  resourceRequest   ResourceRequest? @relation(fields: [resourceRequestId], references: [id])
  resourceRequestId String?
  payment           Payment?         @relation(fields: [paymentId], references: [id])
  paymentId         String?

  statusUpdateRequest   StatusUpdateRequest? @relation("StatusUpdateRequestNotifications", fields: [statusUpdateRequestId], references: [id])
  statusUpdateRequestId String?
}

// Centralized enums for approval lifecycle and notifications
enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  CHANGES_REQUESTED
}

enum NotificationChannel {
  EMAIL
  IN_APP
  PUSH
}

enum NotificationType {
  EVENT_APPROVAL
  EVENT_REGISTRATION
  RESOURCE_REQUEST
  PAYMENT_RECEIPT
  GENERIC
  STATUS_UPDATE_REQUEST
}

// -------------------- MEMBER INVITE --------------------
// Tracks pending requests or invites to join a Family. Created when a user
// requests to join a family or when a Family Head invites an external email.
model MemberInvite {
  id            String       @id @default(uuid())
  family        Family       @relation(fields: [familyId], references: [id])
  familyId      String
  invitedUser   User?        @relation("InvitedUser", fields: [invitedUserId], references: [id])
  invitedUserId String?
  inviteEmail   String?
  status        InviteStatus @default(PENDING)
  token         String?
  createdAt     DateTime     @default(now())
  expiresAt     DateTime?
  reviewedBy    User?        @relation("InviteReviewedBy", fields: [reviewedById], references: [id])
  reviewedById  String?
  reviewedAt    DateTime?
  remarks       String?

  @@unique([familyId, inviteEmail])
  @@index([familyId])
}

enum InviteStatus {
  PENDING
  APPROVED
  REJECTED
}

//
// -------------------- STATUS UPDATE REQUEST --------------------
// Handles marking a user as "deceased" (or similar lifecycle updates).
//

model StatusUpdateRequest {
  id            String                 @id @default(uuid())
  targetUser    User                   @relation("TargetUser", fields: [targetUserId], references: [id])
  targetUserId  String // The user whose profile status is being changed
  requestedBy   User                   @relation("StatusUpdateRequestedBy", fields: [requestedById], references: [id])
  requestedById String // Who initiated the request (family member or family head)
  reason        String? // Optional reason/note
  finalStatus   String? // e.g. "deceased"
  status        ApprovalStatus         @default(PENDING)
  approvals     StatusUpdateApproval[]
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt
  reviewedAt    DateTime?
  Notification  Notification[]         @relation("StatusUpdateRequestNotifications")
}

//
// -------------------- STATUS UPDATE APPROVAL --------------------
// Each approval row represents a role-based reviewer (e.g. GOTRA_HEAD, COMMUNITY_SUBHEAD).
//

model StatusUpdateApproval {
  id           String              @id @default(uuid())
  request      StatusUpdateRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  requestId    String
  approver     User                @relation("UserStatusUpdateApprovals", fields: [approverId], references: [id])
  approverId   String
  approverName String
  role         Role // Only COMMUNITY_SUBHEAD or GOTRA_HEAD expected
  status       ApprovalStatus      @default(PENDING)
  remarks      String?
  reviewedAt   DateTime?
  createdAt    DateTime            @default(now())

  @@unique([requestId, approverId])
}
